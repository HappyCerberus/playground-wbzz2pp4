# $`O(1)`$ data structure

An exercise in understanding performance characteristics of different data structures.

Implement a class with the following methods, all with $`O(1)`$ time complexity:

```C++
class Constant {
public:
	// Insert new key with value 1, or if key is already present, increase it by 1.
	void inc(const string& key);
	// Decrease the value of a key by 1. If the value is already 1, remove it from the data structure.
	void dec(const string& key);
	// Return one of the keys with maximum value. Return "" if datastructure is empty.
	string getMaxKey() const;
	// Return one of the keys with minimum value. Return "" if datastructure is empty.
	string getMinKey() const;
};
```

In this article, we will go through the deconstruction of this problem and build up the solution step by step.

## Trivial $`O(n)`$ "solution"

Let's establish some baseline of what we can definitely do (ignoring $`O(1)`$ time complexity requirement for now).

Fetching the maximum and minimum out of an unsorted sequence requires $`O(n)`$ complexity.

Increasing and decreasing the value for a key can be done in $`O(1)`$ if we store this information in a hash map.

```C++ runnable
// { autofold
#include <unordered_map>
#include <iostream>
using namespace std;
// }

class Constant {
	unordered_map<string, unsigned> _values;
public:
	void inc(const string& key);
	void dec(const string& key);
	string getMaxKey() const;
	string getMinKey() const;
};

void Constant::inc(const string& key) {
	_values[key]++;
}

void Constant::dec(const string& key) {
	_values[key]--;
	if (_values[key] == 0) {
		_values.erase(key);
	}
}

string Constant::getMaxKey() const {
	unsigned max = 0;
	string key = "";
	for (auto v : _values) {
		if (v.second > max) {
			key = v.first;
			max = v.second;
		}
	}

	return key;
}

string Constant::getMinKey() const {
	unsigned min = numeric_limits<unsigned>::max();
	string key = "";
	for (auto v : _values) {
		if (v.second < min) {
			key = v.first;
			min = v.second;
		}
	}

	return key;
}

// { autofold
void do_and_print_inc(const string& key) {
}

void do_and_print_dec(const string& key) {
}

int main() {
	Constant c;

	auto inc = [&c](const string& key) {
		c.inc(key);
		cout << "inc(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;
	};

	auto dec = [&c](const string& key) {
		c.dec(key);
		cout << "dec(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;

	};

	inc("a");
	inc("b");
	inc("b");
	inc("c");
	inc("c");
	inc("c");
	dec("a");
	dec("b");
	dec("b");
}
// }
```

This solution is obviously extremely inefficient. We could improve it drastically by simply caching the result of min and max and only updating it when needed. However that wouldn't give us the desired $`O(1)`$ complexity.

***

Previous: [Top $`k`$ elements and $`k`$-th element](https://tech.io/playgrounds/52679/common-coding-interview-questions-kth-element)

***

[![CC-BY-SA](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).
Šimon Tóth 2020 (kontakt@simontoth.cz)
