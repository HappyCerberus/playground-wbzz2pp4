# $`O(1)`$ data structure

An exercise in understanding performance characteristics of different data structures.

Implement a class with the following methods, all with $`O(1)`$ time complexity:

```C++
class Constant {
public:
	// Insert new key with value 1, or if key is already present, increase it by 1.
	void inc(const string& key);
	// Decrease the value of a key by 1. If the value is already 1, remove it from the data structure.
	void dec(const string& key);
	// Return one of the keys with maximum value. Return "" if datastructure is empty.
	string getMaxKey() const;
	// Return one of the keys with minimum value. Return "" if datastructure is empty.
	string getMinKey() const;
};
```

In this article, we will go through the deconstruction of this problem and build up the solution step by step.

## Trivial $`O(n)`$ "solution"

Let's establish some baseline of what we can definitely do (ignoring $`O(1)`$ time complexity requirement for now).

Fetching the maximum and minimum out of an unsorted sequence requires $`O(n)`$ complexity.

Increasing and decreasing the value for a key can be done in $`O(1)`$ if we store this information in a hash map.

```C++ runnable
// { autofold
#include <unordered_map>
#include <iostream>
using namespace std;
// }

class Constant {
	unordered_map<string, unsigned> _values;
public:
	void inc(const string& key);
	void dec(const string& key);
	string getMaxKey() const;
	string getMinKey() const;
};

void Constant::inc(const string& key) {
	_values[key]++;
}

void Constant::dec(const string& key) {
	_values[key]--;
	if (_values[key] == 0) {
		_values.erase(key);
	}
}

string Constant::getMaxKey() const {
	unsigned max = 0;
	string key = "";
	for (auto v : _values) {
		if (v.second > max) {
			key = v.first;
			max = v.second;
		}
	}

	return key;
}

string Constant::getMinKey() const {
	unsigned min = numeric_limits<unsigned>::max();
	string key = "";
	for (auto v : _values) {
		if (v.second < min) {
			key = v.first;
			min = v.second;
		}
	}

	return key;
}

// { autofold
int main() {
	Constant c;

	auto inc = [&c](const string& key) {
		c.inc(key);
		cout << "inc(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;
	};

	auto dec = [&c](const string& key) {
		c.dec(key);
		cout << "dec(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;

	};

	inc("a");
	inc("b");
	inc("b");
	inc("c");
	inc("c");
	inc("c");
	dec("a");
	dec("b");
	dec("b");
}
// }
```

This solution is obviously extremely inefficient. We could improve it drastically by simply caching the result of min and max and only updating it when needed. However that wouldn't give us the desired $`O(1)`$ complexity.

## Solving the maximum in $`O(1)`$

Our previous trivial implementation would work even if the values for the keys could change arbitrarily. Can we exploit the fact that a key can only change by one?

Let's have a look at what can happen to the maximum if we increase or decrease the value for a key.

1. if the key was not the maximum, the maximum will not change
2. increasing a maximum key will increase the maximum
3. decreasing a maximum key can have two results:
   1. if this was the only key at the value, the maximum decreases
   2. if there are other keys with the value, the maximum does not change

Looking at this, the only information we are missing is how many keys are at a given value. We can maintain this information in $`O(1)`$ using a hash map. Since we need to return the maximum key (not the maximum value) we will also need to store the keys at a given value, hash set will work fine for this purpose.

```C++ runnable
// { autofold
#include <unordered_map>
#include <unordered_set>
#include <iostream>
using namespace std;
// }
class Constant {
	unordered_map<string, unsigned> _values;
	unordered_map<unsigned, unordered_set<string>> _buckets;
	unsigned max = 0;
public:
	void inc(const string& key);
	void dec(const string& key);
	string getMaxKey() const;
	string getMinKey() const;
};

void Constant::inc(const string& key) {
	if (max == _values[key]) {
		max++;
	}

	_values[key]++;
	if (_values[key] > 1) {
		_buckets[_values[key]-1].erase(key);
	}
	_buckets[_values[key]].insert(key);
}

void Constant::dec(const string& key) {
	if (max == _values[key] && _buckets[_values[key]].size() == 1) {
		max--;
	}

	_values[key]--;
	_buckets[_values[key]+1].erase(key);
	if (_values[key] != 0) {
		_buckets[_values[key]].insert(key);
	} else {
		_values.erase(key);
	}
}

string Constant::getMaxKey() const {
	auto it = _buckets.find(max);
	if (it == _buckets.end()) return string("");
	return *it->second.begin();
}

string Constant::getMinKey() const {
	unsigned min = numeric_limits<unsigned>::max();
	string key = "";
	for (auto v : _values) {
		if (v.second < min) {
			key = v.first;
			min = v.second;
		}
	}

	return key;
}
// { autofold
int main() {
	Constant c;

	auto inc = [&c](const string& key) {
		c.inc(key);
		cout << "inc(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;
	};

	auto dec = [&c](const string& key) {
		c.dec(key);
		cout << "dec(\"" << key << "\") min = \"" << c.getMinKey() << "\" max = \"" << c.getMaxKey() << "\"" << endl;

	};

	inc("a");
	inc("b");
	inc("b");
	inc("c");
	inc("c");
	inc("c");
	dec("a");
	dec("b");
	dec("b");
}
// }
```

## Solving minimum in $`O(1)`$

At first glance, we might be able to use the same approach for minimum. That will unfortunately not work. Maximum always changes smoothly, at most by one. Minimum can however change by an arbitrary amount if the minimum key has the value $`1`$ and we decrement it.

The pathological example would be to have the following keys in our datastructure:

```
{ a: 1, b: 2, c: 3, d: 4, ....}
```

If we always decrement the minimum key until it drops out of the datastructure, we will need to repeatedly determine the 2nd lowest key.

The only way to do this in $`O(1)`$ is to somehow maintain our keys in a sorted way during the increments and decrements.

***

Previous: [Top $`k`$ elements and $`k`$-th element](https://tech.io/playgrounds/52679/common-coding-interview-questions-kth-element)

***

[![CC-BY-SA](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/).
Šimon Tóth 2020 (kontakt@simontoth.cz)
